{"path":"/workspace/C++/para_lingam/ParaLingam.cpp","name":"ParaLingam.cpp","has_active_debug_locs":false,"absName":"/workspace/C++/para_lingam/ParaLingam.cpp","content":"#include \"ParaLingam.hpp\"\u000A#include <iostream>\u000A#include <numeric>\u000A#include <algorithm>\u000A#include <cmath>\u000A\u000A// This header is now included for the FPGA selectors.\u000A#include <sycl/ext/intel/fpga_extensions.hpp>\u000A\u000A// DPC++ Kernel for standardizing data (mean=0, std=1 for each column).\u000Avoid ParaLingamCausalOrderAlgorithm::standardize_data(sycl::queue& q, sycl::buffer<float, 2>& buffer_x) {\u000A    const auto num_rows = buffer_x.get_range()[0];\u000A    const auto num_cols = buffer_x.get_range()[1];\u000A\u000A    q.submit([&](sycl::handler& h) {\u000A        auto accessor_x = buffer_x.get_access<sycl::access::mode::read_write>(h);\u000A        \u000A        h.parallel_for(sycl::range<1>(num_cols), [=](sycl::id<1> col_idx) {\u000A            float sum = 0.0f;\u000A            float sum_sq = 0.0f;\u000A\u000A            for (size_t row = 0; row < num_rows; ++row) {\u000A                float val = accessor_x[row][col_idx];\u000A                sum += val;\u000A                sum_sq += val * val;\u000A            }\u000A\u000A            float mean = sum / num_rows;\u000A            float std_dev = sycl::sqrt(sum_sq / num_rows - mean * mean);\u000A\u000A            if (std_dev > 1e-9f) {\u000A                for (size_t row = 0; row < num_rows; ++row) {\u000A                    accessor_x[row][col_idx] = (accessor_x[row][col_idx] - mean) / std_dev;\u000A                }\u000A            }\u000A        });\u000A    }).wait();\u000A}\u000A\u000A// DPC++ Kernel for calculating the covariance matrix of standardized data.\u000Avoid ParaLingamCausalOrderAlgorithm::calculate_covariance(sycl::queue& q, sycl::buffer<float, 2>& buffer_x, sycl::buffer<float, 2>& buffer_cov) {\u000A    const auto num_rows = buffer_x.get_range()[0];\u000A    const auto num_cols = buffer_x.get_range()[1];\u000A\u000A    q.submit([&](sycl::handler& h) {\u000A        auto accessor_x = buffer_x.get_access<sycl::access::mode::read>(h);\u000A        auto accessor_cov = buffer_cov.get_access<sycl::access::mode::write>(h);\u000A        \u000A        h.parallel_for(sycl::range<2>(num_cols, num_cols), [=](sycl::id<2> idx) {\u000A            size_t i = idx[0];\u000A            size_t j = idx[1];\u000A\u000A            if (i > j) return;\u000A\u000A            float cov_sum = 0.0f;\u000A            for (size_t k = 0; k < num_rows; ++k) {\u000A                cov_sum += accessor_x[k][i] * accessor_x[k][j];\u000A            }\u000A            \u000A            float covariance = cov_sum / (num_rows -1);\u000A            accessor_cov[i][j] = covariance;\u000A            if (i != j) {\u000A                accessor_cov[j][i] = covariance;\u000A            }\u000A        });\u000A    }).wait();\u000A}\u000A\u000A// DPC++ implementation of the parallel root finding.\u000A// DPC++ implementation of the parallel root finding (REVISED to avoid atomics).\u000A// DPC++ implementation of the parallel root finding (REVISED for memory efficiency on FPGA).\u000A// DPC++ implementation of the parallel root finding (REVISED to avoid atomics).\u000Aint ParaLingamCausalOrderAlgorithm::para_find_root(sycl::queue& q, sycl::buffer<float, 2>& buffer_x, sycl::buffer<float, 2>& buffer_cov) {\u000A    const auto num_rows = buffer_x.get_range()[0];\u000A    const auto num_cols = buffer_x.get_range()[1];\u000A\u000A    if (num_cols <= 1) return 0;\u000A\u000A    // Step 1: \"Scatter\" Kernel.\u000A    // Calculate partial scores for each pair (i, j) and store them in a temporary\u000A    // matrix. This avoids the need for atomic operations by giving each pair\u000A    // its own unique memory location to write to.\u000A    sycl::buffer<float, 2> buffer_partial_scores(sycl::range<2>(num_cols, num_cols));\u000A\u000A    q.submit([&](sycl::handler& h) {\u000A        auto accessor_x = buffer_x.get_access<sycl::access::mode::read>(h);\u000A        auto accessor_cov = buffer_cov.get_access<sycl::access::mode::read>(h);\u000A        auto accessor_partial = buffer_partial_scores.get_access<sycl::access::mode::write>(h);\u000A\u000A        h.parallel_for(sycl::range<2>(num_cols, num_cols), [=](sycl::id<2> idx) {\u000A            size_t i = idx[0];\u000A            size_t j = idx[1];\u000A\u000A            // Initialize the cell to 0 before proceeding.\u000A            accessor_partial[i][j] = 0.0f;\u000A            \u000A            // We only need to compute for the upper triangle of the matrix (where j > i).\u000A            if (i >= j) return;\u000A\u000A            auto entropy = [=](const float* u_ptr) -> float {\u000A                constexpr float k1 = 79.047f;\u000A                constexpr float k2 = 7.4129f;\u000A                constexpr float gamma = 0.37457f;\u000A\u000A                float sum_log_cosh = 0.0f;\u000A                float sum_u_exp = 0.0f;\u000A\u000A                for(size_t k = 0; k < num_rows; k++) {\u000A                   sum_log_cosh += sycl::log(sycl::cosh(u_ptr[k]));\u000A                   sum_u_exp += u_ptr[k] * sycl::exp(-0.5f * u_ptr[k] * u_ptr[k]);\u000A                }\u000A                float mean_log_cosh = sum_log_cosh / num_rows;\u000A                float mean_u_exp = sum_u_exp / num_rows;\u000A                \u000A                float term1 = (mean_log_cosh - gamma);\u000A                float term2 = mean_u_exp;\u000A                \u000A                return (1.0f + sycl::log(2.0f * M_PI))/2.0f - k1 * term1 * term1 - k2 * term2 * term2;\u000A            };\u000A\u000A            float cov_ij = accessor_cov[i][j];\u000A            float ri_j[2048], rj_i[2048]; \u000A\u000A            for (size_t k = 0; k < num_rows; k++) {\u000A                ri_j[k] = accessor_x[k][i] - cov_ij * accessor_x[k][j];\u000A                rj_i[k] = accessor_x[k][j] - cov_ij * accessor_x[k][i];\u000A            }\u000A\u000A            float h_ri_j = entropy(ri_j);\u000A            float h_rj_i = entropy(rj_i);\u000A            float diff_mi = h_ri_j - h_rj_i;\u000A            \u000A            float score_contribution_i = sycl::min(0.0f, diff_mi) * sycl::min(0.0f, diff_mi);\u000A            float score_contribution_j = sycl::min(0.0f, -diff_mi) * sycl::min(0.0f, -diff_mi);\u000A\u000A            // Write the partial scores to unique locations in the matrix.\u000A            accessor_partial[i][j] = score_contribution_i;\u000A            accessor_partial[j][i] = score_contribution_j;\u000A        });\u000A    }).wait();\u000A\u000A    // Step 2: \"Reduce\" Kernel.\u000A    // Sum the partial scores for each variable (i.e., each row of the partial matrix)\u000A    // into the final scores vector.\u000A    // CORRECT\u000A    std::vector<float> host_scores(num_cols, 0.0f);\u000A    sycl::buffer<float, 1> buffer_scores(host_scores.data(), sycl::range<1>(num_cols));\u000A\u000A    q.submit([&](sycl::handler& h) {\u000A        auto accessor_partial = buffer_partial_scores.get_access<sycl::access::mode::read>(h);\u000A        auto accessor_scores = buffer_scores.get_access<sycl::access::mode::write>(h);\u000A\u000A        h.parallel_for(sycl::range<1>(num_cols), [=](sycl::id<1> i) {\u000A            float total_score = 0.0f;\u000A            for (size_t j = 0; j < num_cols; ++j) {\u000A                total_score += accessor_partial[i][j];\u000A            }\u000A            accessor_scores[i] = total_score;\u000A        });\u000A    }).wait();\u000A\u000A    // Step 3: Find the minimum score on the host.\u000A    auto final_scores = buffer_scores.get_host_access();\u000A    int root_idx = std::distance(final_scores.begin(), std::min_element(final_scores.begin(), final_scores.end()));\u000A    return root_idx;\u000A}\u000A\u000Astd::vector<int> ParaLingamCausalOrderAlgorithm::get_causal_order_using_paralingam(sycl::queue& q, const Matrix& matrix) {\u000A    size_t n_samples = matrix.rows;\u000A    size_t n_features = matrix.cols;\u000A\u000A    std::vector<int> U;\u000A    for(int i=0; i<n_features; ++i) U.push_back(i);\u000A    std::vector<int> K;\u000A\u000A    Matrix current_matrix = matrix;\u000A\u000A    for (size_t k = 0; k < n_features - 1; ++k) {\u000A        sycl::buffer<float, 2> buffer_x(current_matrix.data.data(), sycl::range<2>(current_matrix.rows, current_matrix.cols));\u000A        sycl::buffer<float, 2> buffer_cov(sycl::range<2>(current_matrix.cols, current_matrix.cols));\u000A\u000A        standardize_data(q, buffer_x);\u000A        calculate_covariance(q, buffer_x, buffer_cov);\u000A        \u000A        int root_idx_in_current = para_find_root(q, buffer_x, buffer_cov);\u000A        \u000A        int original_root_idx = U[root_idx_in_current];\u000A        K.push_back(original_root_idx);\u000A        U.erase(U.begin() + root_idx_in_current);\u000A\u000A        size_t n_remaining = current_matrix.cols - 1;\u000A        Matrix next_matrix;\u000A        next_matrix.rows = n_samples;\u000A        next_matrix.cols = n_remaining;\u000A        next_matrix.data.resize(n_samples * n_remaining);\u000A\u000A        {\u000A            sycl::buffer<float, 2> buffer_next_x(next_matrix.data.data(), sycl::range<2>(n_samples, n_remaining));\u000A\u000A            q.submit([&](sycl::handler& h) {\u000A                auto accessor_x = buffer_x.get_access<sycl::access::mode::read>(h);\u000A                auto accessor_cov = buffer_cov.get_access<sycl::access::mode::read>(h);\u000A                auto next_accessor = buffer_next_x.get_access<sycl::access::mode::write>(h);\u000A\u000A                h.parallel_for(sycl::range<1>(n_remaining), [=](sycl::id<1> i_rem) {\u000A                    int i_curr = (i_rem[0] < root_idx_in_current) ? i_rem[0] : i_rem[0] + 1;\u000A                    float cov_ir = accessor_cov[i_curr][root_idx_in_current];\u000A                    float residual_std_dev = sycl::sqrt(sycl::fabs(1.0f - cov_ir * cov_ir));\u000A\u000A                    for (size_t row = 0; row < n_samples; ++row) {\u000A                        float residual = accessor_x[row][i_curr] - cov_ir * accessor_x[row][root_idx_in_current];\u000A                        if (residual_std_dev > 1e-9f) {\u000A                            next_accessor[row][i_rem] = residual / residual_std_dev;\u000A                        } else {\u000A                            next_accessor[row][i_rem] = 0.0f;\u000A                        }\u000A                    }\u000A                });\u000A            }).wait();\u000A        } \u000A        current_matrix = std::move(next_matrix);\u000A    }\u000A    \u000A    if (!U.empty()) {\u000A        K.push_back(U[0]);\u000A    }\u000A\u000A    return K;\u000A}\u000A\u000Astd::vector<int> ParaLingamCausalOrderAlgorithm::run(const Matrix& matrix) {\u000A    auto exception_handler = [](sycl::exception_list exceptions) {\u000A        for (std::exception_ptr const& e : exceptions) {\u000A            try {\u000A                std::rethrow_exception(e);\u000A            } catch (sycl::exception const& e) {\u000A                std::cerr << \"Caught SYCL exception: \" << e.what() << std::endl;\u000A            }\u000A        }\u000A    };\u000A    \u000A    // Use preprocessor macros to select the device based on compiler flags.\u000A    #if defined(FPGA_EMULATOR)\u000A        sycl::queue q(sycl::ext::intel::fpga_emulator_selector_v, exception_handler);\u000A    #elif defined(FPGA_HARDWARE) // This case is added for the report/hardware flow\u000A        sycl::queue q(sycl::ext::intel::fpga_selector_v, exception_handler);\u000A    #elif defined(GPU)\u000A        sycl::queue q(sycl::gpu_selector_v, exception_handler);\u000A    #else\u000A        // Default to the CPU selector if no specific target is defined\u000A        sycl::queue q(sycl::cpu_selector_v, exception_handler);\u000A    #endif\u000A\u000A    std::cout << \"Running on device: \" << q.get_device().get_info<sycl::info::device::name>() << std::endl;\u000A    \u000A    return get_causal_order_using_paralingam(q, matrix);\u000A}\u000A\u000Astd::string ParaLingamCausalOrderAlgorithm::to_string() const {\u000A    return \"ParaLingamAlgorithm\";\u000A}"}
{"path":"/workspace/C++/para_lingam/ParaLingam.hpp","name":"ParaLingam.hpp","has_active_debug_locs":false,"absName":"/workspace/C++/para_lingam/ParaLingam.hpp","content":"#ifndef PARALINGAM_HPP\u000A#define PARALINGAM_HPP\u000A\u000A#include <sycl/sycl.hpp>\u000A#include <vector>\u000A#include <string>\u000A\u000A// A simple structure to hold the matrix data and its dimensions.\u000Astruct Matrix {\u000A    std::vector<float> data;\u000A    size_t rows;\u000A    size_t cols;\u000A};\u000A\u000Aclass ParaLingamCausalOrderAlgorithm {\u000Apublic:\u000A    // Runs the causal order algorithm.\u000A    std::vector<int> run(const Matrix& matrix);\u000A    std::string to_string() const;\u000A\u000Aprivate:\u000A    // Main algorithm logic implemented using DPC++.\u000A    std::vector<int> get_causal_order_using_paralingam(sycl::queue& q, const Matrix& matrix);\u000A\u000A    // DPC++ helper functions for various stages of the algorithm.\u000A    // FIX 2: Removed const from buffer parameters to match .cpp definitions.\u000A    void standardize_data(sycl::queue& q, sycl::buffer<float, 2>& buffer_x);\u000A    void calculate_covariance(sycl::queue& q, sycl::buffer<float, 2>& buffer_x, sycl::buffer<float, 2>& buffer_cov);\u000A    int para_find_root(sycl::queue& q, sycl::buffer<float, 2>& buffer_x, sycl::buffer<float, 2>& buffer_cov);\u000A};\u000A\u000A#endif // PARALINGAM_HPP"}
{"path":"/workspace/C++/para_lingam/main.cpp","name":"main.cpp","has_active_debug_locs":false,"absName":"/workspace/C++/para_lingam/main.cpp","content":"#include \"ParaLingam.hpp\"\u000A#include <iostream>\u000A#include <random>\u000A#include <chrono>\u000A\u000A// Generates the same sample data as the Python example.\u000AMatrix get_matrix() {\u000A    constexpr size_t n_samples = 1000;\u000A    std::vector<float> x0(n_samples), x1(n_samples), x2(n_samples),\u000A                         x3(n_samples), x4(n_samples), x5(n_samples);\u000A\u000A    std::mt19937 gen(42);\u000A    std::uniform_real_distribution<float> dis(0.0, 1.0);\u000A\u000A    for (size_t i = 0; i < n_samples; ++i) x3[i] = dis(gen);\u000A    for (size_t i = 0; i < n_samples; ++i) x0[i] = 3.0f * x3[i] + dis(gen);\u000A    for (size_t i = 0; i < n_samples; ++i) x2[i] = 6.0f * x3[i] + dis(gen);\u000A    for (size_t i = 0; i < n_samples; ++i) x1[i] = 3.0f * x0[i] + 2.0f * x2[i] + dis(gen);\u000A    for (size_t i = 0; i < n_samples; ++i) x5[i] = 4.0f * x0[i] + dis(gen);\u000A    for (size_t i = 0; i < n_samples; ++i) x4[i] = 8.0f * x0[i] - 1.0f * x2[i] + dis(gen);\u000A\u000A    Matrix m;\u000A    m.rows = n_samples;\u000A    m.cols = 6;\u000A    m.data.resize(n_samples * 6);\u000A\u000A    // Store data in column-major format\u000A    for (size_t i = 0; i < n_samples; ++i) {\u000A        m.data[i + 0 * n_samples] = x0[i];\u000A        m.data[i + 1 * n_samples] = x1[i];\u000A        m.data[i + 2 * n_samples] = x2[i];\u000A        m.data[i + 3 * n_samples] = x3[i];\u000A        m.data[i + 4 * n_samples] = x4[i];\u000A        m.data[i + 5 * n_samples] = x5[i];\u000A    }\u000A    return m;\u000A}\u000A\u000Aint main() {\u000A    std::cout << \"Running Parallelised ParaLiNGAM Algorithm in DPC++...\" << std::endl;\u000A\u000A    ParaLingamCausalOrderAlgorithm algorithm;\u000A    Matrix data = get_matrix();\u000A\u000A    auto start = std::chrono::high_resolution_clock::now();\u000A    std::vector<int> causal_order = algorithm.run(data);\u000A    auto end = std::chrono::high_resolution_clock::now();\u000A\u000A    std::chrono::duration<double> duration = end - start;\u000A\u000A    std::cout << \"Causal Order: [ \";\u000A    for (int val : causal_order) {\u000A        std::cout << val << \" \";\u000A    }\u000A    std::cout << \"]\" << std::endl;\u000A\u000A    std::cout << \"Execution Time: \" << duration.count() << \" seconds\" << std::endl;\u000A\u000A    return 0;\u000A}"}
{"path":"/opt/intel/oneapi/tbb/2022.0/include/tbb/tbb.h","name":"tbb.h","has_active_debug_locs":false,"absName":"/opt/intel/oneapi/tbb/2022.0/include/tbb/tbb.h","content":"/*\u000A    Copyright (c) 2005-2021 Intel Corporation\u000A\u000A    Licensed under the Apache License, Version 2.0 (the \"License\");\u000A    you may not use this file except in compliance with the License.\u000A    You may obtain a copy of the License at\u000A\u000A        http://www.apache.org/licenses/LICENSE-2.0\u000A\u000A    Unless required by applicable law or agreed to in writing, software\u000A    distributed under the License is distributed on an \"AS IS\" BASIS,\u000A    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\u000A    See the License for the specific language governing permissions and\u000A    limitations under the License.\u000A*/\u000A\u000A#include \"../oneapi/tbb.h\"\u000A"}