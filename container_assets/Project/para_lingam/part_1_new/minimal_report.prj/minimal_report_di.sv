// (c) 1992-2024 Intel Corporation.                                             
// Intel, the Intel logo, Intel, MegaCore, NIOS II, Quartus and TalkBack        
// words and logos are trademarks of Intel Corporation or its                   
// subsidiaries in the U.S. and/or other countries. Other marks and             
// brands may be claimed as the property of others.                             
// See Trademarks on intel.com for full list of Intel trademarks or the         
// Trademarks & Brands Names Database (if Intel)                                
// or See www.Intel.com/legal (if Altera)                                       
// Your use of Intel Corporation's design tools, logic functions and            
// other software and tools, and its AMPP partner logic functions, and          
// any output files any of the foregoing (including device programming          
// or simulation files), and any associated documentation or information        
// are expressly subject to the terms and conditions of the Altera              
// Program License Subscription Agreement, Intel MegaCore Function              
// License Agreement, or other applicable license agreement, including,         
// without limitation, that your use is for the sole purpose of                 
// programming logic devices manufactured by Intel and sold by Intel or         
// its authorized distributors.                                                 
// Please refer to the applicable agreement for further details.                
// Generated by Intel(R) FPGA SDK for OpenCL(TM), Version 2025.0.0 Build 485db989daf205d1f3115c250809abcd4faf0211 Pro Edition, Copyright (c) 2024 Intel Corporation

/////////////////////////////////////////////////////////////////
// MODULE minimal_report_di
/////////////////////////////////////////////////////////////////
module minimal_report_di
(
   input logic clock,
   input logic resetn,
   output logic [63:0] device_exception_bus,
   output logic kernel_irqs,
   // AVS csr_ring_root_avs
   input logic csr_ring_root_avs_enable,
   input logic csr_ring_root_avs_read,
   input logic csr_ring_root_avs_write,
   input logic [4:0] csr_ring_root_avs_address,
   input logic [63:0] csr_ring_root_avs_writedata,
   input logic [7:0] csr_ring_root_avs_byteenable,
   output logic csr_ring_root_avs_waitrequest,
   output logic [63:0] csr_ring_root_avs_readdata,
   output logic csr_ring_root_avs_readdatavalid
);
   logic cra_ring_node_avm_wire_0_enable;
   logic cra_ring_node_avm_wire_0_read;
   logic cra_ring_node_avm_wire_0_write;
   logic [4:0] cra_ring_node_avm_wire_0_address;
   logic [63:0] cra_ring_node_avm_wire_0_writedata;
   logic [7:0] cra_ring_node_avm_wire_0_byteenable;
   logic [63:0] cra_ring_node_avm_wire_0_readdata;
   logic cra_ring_node_avm_wire_0_readdatavalid;
   logic cra_ring_node_avm_wire_0_burstcount;

   // INST const_lambda_std_ic_inst of const_lambda_std_ic_partition_wrapper
   const_lambda_std_ic_partition_wrapper const_lambda_std_ic_inst
   (
      .clock(clock),
      .resetn(resetn),
      .cra_irq_const_lambda(kernel_irqs),
      // AVS avs_const_lambda_cra
      .avs_const_lambda_cra_enable(cra_ring_node_avm_wire_0_enable),
      .avs_const_lambda_cra_read(cra_ring_node_avm_wire_0_read),
      .avs_const_lambda_cra_write(cra_ring_node_avm_wire_0_write),
      .avs_const_lambda_cra_address(cra_ring_node_avm_wire_0_address),
      .avs_const_lambda_cra_writedata(cra_ring_node_avm_wire_0_writedata),
      .avs_const_lambda_cra_byteenable(cra_ring_node_avm_wire_0_byteenable),
      .avs_const_lambda_cra_readdata(cra_ring_node_avm_wire_0_readdata),
      .avs_const_lambda_cra_readdatavalid(cra_ring_node_avm_wire_0_readdatavalid)
   );

   // INST cra_ring_wrapper_inst of cra_ring_wrapper
   cra_ring_wrapper cra_ring_wrapper_inst
   (
      .clock(clock),
      .resetn(resetn),
      // AVS csr_ring_root_avs
      .csr_ring_root_avs_enable(csr_ring_root_avs_enable),
      .csr_ring_root_avs_read(csr_ring_root_avs_read),
      .csr_ring_root_avs_write(csr_ring_root_avs_write),
      .csr_ring_root_avs_address(csr_ring_root_avs_address),
      .csr_ring_root_avs_writedata(csr_ring_root_avs_writedata),
      .csr_ring_root_avs_byteenable(csr_ring_root_avs_byteenable),
      .csr_ring_root_avs_waitrequest(csr_ring_root_avs_waitrequest),
      .csr_ring_root_avs_readdata(csr_ring_root_avs_readdata),
      .csr_ring_root_avs_readdatavalid(csr_ring_root_avs_readdatavalid),
      // AVM cra_ring_avm_0
      .cra_ring_avm_0_enable(cra_ring_node_avm_wire_0_enable),
      .cra_ring_avm_0_read(cra_ring_node_avm_wire_0_read),
      .cra_ring_avm_0_write(cra_ring_node_avm_wire_0_write),
      .cra_ring_avm_0_address(cra_ring_node_avm_wire_0_address),
      .cra_ring_avm_0_writedata(cra_ring_node_avm_wire_0_writedata),
      .cra_ring_avm_0_byteenable(cra_ring_node_avm_wire_0_byteenable),
      .cra_ring_avm_0_readdata(cra_ring_node_avm_wire_0_readdata),
      .cra_ring_avm_0_readdatavalid(cra_ring_node_avm_wire_0_readdatavalid),
      .cra_ring_avm_0_burstcount(cra_ring_node_avm_wire_0_burstcount)
   );

endmodule

/////////////////////////////////////////////////////////////////
// MODULE const_lambda_std_ic_partition_wrapper
/////////////////////////////////////////////////////////////////
module const_lambda_std_ic_partition_wrapper
(
   input logic clock,
   input logic resetn,
   output logic cra_irq_const_lambda,
   // AVS avs_const_lambda_cra
   input logic avs_const_lambda_cra_enable,
   input logic avs_const_lambda_cra_read,
   input logic avs_const_lambda_cra_write,
   input logic [4:0] avs_const_lambda_cra_address,
   input logic [63:0] avs_const_lambda_cra_writedata,
   input logic [7:0] avs_const_lambda_cra_byteenable,
   output logic [63:0] avs_const_lambda_cra_readdata,
   output logic avs_const_lambda_cra_readdatavalid
);
   logic const_lambda_start;
   logic [0:0] const_lambda_start_chain;
   logic [0:0] const_lambda_start_kernel_copy;
   logic [0:0] const_lambda_start_task_fd;
   logic [0:0] const_lambda_start_finish_element;
   logic const_lambda_finish_sig;
   logic [0:0] const_lambda_finish_kernel_copy;
   logic [0:0] const_lambda_finish_chain;
   logic [63:0] const_lambda_global_size [2:0];
   logic [31:0] const_lambda_num_groups [2:0];
   logic [31:0] const_lambda_local_size [2:0];
   logic [63:0] const_lambda_global_offset [2:0];
   logic [31:0] const_lambda_work_dim;
   logic [31:0] const_lambda_wg_size;
   logic [0:0] const_lambda_wg_disp_stall_in;
   logic [0:0] const_lambda_wg_disp_stall_in_lookahead;
   logic [0:0] const_lambda_wg_disp_valid_out;
   logic const_lambda_wg_disp_start_out;
   logic [31:0] const_lambda_wg_disp_group_id_out [2:0];
   logic [31:0] const_lambda_wg_disp_global_id_base_out [2:0];
   logic const_lambda_wg_disp_dispatched_all_groups;
   logic [63:0] const_lambda_global_id [1][2:0];
   logic [31:0] const_lambda_local_id [1][2:0];
   logic [31:0] const_lambda_group_id [1][2:0];
   logic [0:0] const_lambda_pending_write;
   logic [0:0] const_lambda_lsu_active;
   logic [0:0] const_lambda_valid_in;
   logic [0:0] const_lambda_valid_out;
   logic [0:0] const_lambda_stall_in;
   logic [0:0] const_lambda_stall_out;
   logic const_lambda_csr_pending_write;
   logic const_lambda_csr_lsu_active;
   logic const_lambda_csr_valid_in;
   logic const_lambda_resetn_delayed;

   assign const_lambda_start_chain[0] = const_lambda_start;
   assign const_lambda_finish_chain[0] = 1'b1;
   assign const_lambda_csr_pending_write = |const_lambda_pending_write;
   assign const_lambda_csr_lsu_active = |const_lambda_lsu_active;
   assign const_lambda_csr_valid_in = |const_lambda_valid_in;
   assign const_lambda_stall_in = 0;
   // INST const_lambda_csr_agent_inst of const_lambda_function_cra_agent
   const_lambda_function_cra_agent const_lambda_csr_agent_inst
   (
      .clock(clock),
      .resetn(const_lambda_resetn_delayed),
      .kernel_start(const_lambda_start),
      .kernel_done(const_lambda_finish_sig),
      .has_a_lsu_active(const_lambda_csr_lsu_active),
      .has_a_write_pending(const_lambda_csr_pending_write),
      .valid_in(const_lambda_csr_valid_in),
      .cra_irq(cra_irq_const_lambda),
      // AVS avs_cra
      .avs_cra_enable(avs_const_lambda_cra_enable),
      .avs_cra_read(avs_const_lambda_cra_read),
      .avs_cra_write(avs_const_lambda_cra_write),
      .avs_cra_address(avs_const_lambda_cra_address),
      .avs_cra_writedata(avs_const_lambda_cra_writedata),
      .avs_cra_byteenable(avs_const_lambda_cra_byteenable),
      .avs_cra_readdata(avs_const_lambda_cra_readdata),
      .avs_cra_readdatavalid(avs_const_lambda_cra_readdatavalid)
   );

   // INST const_lambda_csr_agent_reset_delay_inst of acl_reset_handler
   acl_reset_handler
   #(
      .ASYNC_RESET(0),
      .SYNCHRONIZE_ACLRN(1),
      .USE_SYNCHRONIZER(1),
      .PULSE_EXTENSION(0),
      .PIPE_DEPTH(10),
      .NUM_COPIES(1)
   )
   const_lambda_csr_agent_reset_delay_inst
   (
      .clk(clock),
      .i_resetn(resetn),
      .o_aclrn(),
      .o_sclrn(const_lambda_resetn_delayed),
      .o_resetn_synchronized()
   );

   // INST const_lambda_inst_0 of const_lambda_top_wrapper_0
   const_lambda_top_wrapper_0 const_lambda_inst_0
   (
      .start(const_lambda_start_kernel_copy[0]),
      .kernel_valid_in(const_lambda_valid_in[0]),
      .kernel_valid_out(const_lambda_valid_out[0]),
      .has_a_write_pending(const_lambda_pending_write[0]),
      .has_a_lsu_active(const_lambda_lsu_active[0]),
      .clock(clock),
      .resetn(resetn)
   );

   // INST const_lambda_start_elem_inst_0 of acl_start_signal_chain_element
   acl_start_signal_chain_element
   #(
      .ASYNC_RESET(0),
      .SYNCHRONIZE_RESET(1)
   )
   const_lambda_start_elem_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start_in(const_lambda_start_chain[0]),
      .start_kernel(const_lambda_start_kernel_copy[0]),
      .start_finish_detector(const_lambda_start_task_fd[0]),
      .start_finish_chain_element(const_lambda_start_finish_element[0]),
      .start_chain()
   );

   // INST const_lambda_task_finish_detector_inst_0 of acl_task_copy_finish_detector
   acl_task_copy_finish_detector
   #(
      .ASYNC_RESET(0),
      .SYNCHRONIZE_RESET(1)
   )
   const_lambda_task_finish_detector_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start(const_lambda_start_task_fd[0]),
      .kernel_copy_valid_out(const_lambda_valid_out[0]),
      .kernel_copy_has_pending_write(const_lambda_pending_write[0]),
      .kernel_copy_finished(const_lambda_finish_kernel_copy[0])
   );

   // INST const_lambda_finish_elem_inst_0 of acl_finish_signal_chain_element
   acl_finish_signal_chain_element
   #(
      .ASYNC_RESET(0),
      .SYNCHRONIZE_RESET(1)
   )
   const_lambda_finish_elem_inst_0
   (
      .clock(clock),
      .resetn(resetn),
      .start(const_lambda_start_finish_element[0]),
      .kernel_copy_finished(const_lambda_finish_kernel_copy[0]),
      .finish_in(const_lambda_finish_chain[0]),
      .finish_out(const_lambda_finish_sig)
   );

endmodule

/////////////////////////////////////////////////////////////////
// MODULE const_lambda_top_wrapper_0
/////////////////////////////////////////////////////////////////
module const_lambda_top_wrapper_0
(
   input logic start,
   output logic kernel_valid_in,
   output logic kernel_valid_out,
   output logic has_a_write_pending,
   output logic has_a_lsu_active,
   input logic clock,
   input logic resetn
);
   logic lmem_invalid_single_bit;

   // INST kernel of const_lambda_function_wrapper
   const_lambda_function_wrapper kernel
   (
      .local_router_hang(lmem_invalid_single_bit),
      .start(start),
      .kernel_valid_in(kernel_valid_in),
      .kernel_valid_out(kernel_valid_out),
      .has_a_write_pending(has_a_write_pending),
      .has_a_lsu_active(has_a_lsu_active),
      .clock(clock),
      .resetn(resetn)
   );

   assign lmem_invalid_single_bit = 'b0;
endmodule

/////////////////////////////////////////////////////////////////
// MODULE cra_ring_wrapper
/////////////////////////////////////////////////////////////////
module cra_ring_wrapper
(
   input logic clock,
   input logic resetn,
   // AVS csr_ring_root_avs
   input logic csr_ring_root_avs_enable,
   input logic csr_ring_root_avs_read,
   input logic csr_ring_root_avs_write,
   input logic [4:0] csr_ring_root_avs_address,
   input logic [63:0] csr_ring_root_avs_writedata,
   input logic [7:0] csr_ring_root_avs_byteenable,
   output logic csr_ring_root_avs_waitrequest,
   output logic [63:0] csr_ring_root_avs_readdata,
   output logic csr_ring_root_avs_readdatavalid,
   // AVM cra_ring_avm_0
   output logic cra_ring_avm_0_enable,
   output logic cra_ring_avm_0_read,
   output logic cra_ring_avm_0_write,
   output logic [4:0] cra_ring_avm_0_address,
   output logic [63:0] cra_ring_avm_0_writedata,
   output logic [7:0] cra_ring_avm_0_byteenable,
   input logic [63:0] cra_ring_avm_0_readdata,
   input logic cra_ring_avm_0_readdatavalid,
   output logic cra_ring_avm_0_burstcount
);
   logic csr_ring_root_ring_in_wire_read;
   logic csr_ring_root_ring_in_wire_write;
   logic [4:0] csr_ring_root_ring_in_wire_addr;
   logic [63:0] csr_ring_root_ring_in_wire_data;
   logic [63:0] csr_ring_root_ring_in_wire_readdata;
   logic [7:0] csr_ring_root_ring_in_wire_byteena;
   logic csr_ring_root_ring_in_wire_datavalid;
   logic csr_ring_root_ring_out_wire_read;
   logic csr_ring_root_ring_out_wire_write;
   logic [4:0] csr_ring_root_ring_out_wire_addr;
   logic [63:0] csr_ring_root_ring_out_wire_data;
   logic [63:0] csr_ring_root_ring_out_wire_readdata;
   logic [7:0] csr_ring_root_ring_out_wire_byteena;
   logic csr_ring_root_ring_out_wire_datavalid;
   logic cra_ring_node_ring_out_wire_0_read;
   logic cra_ring_node_ring_out_wire_0_write;
   logic [4:0] cra_ring_node_ring_out_wire_0_addr;
   logic [63:0] cra_ring_node_ring_out_wire_0_data;
   logic [63:0] cra_ring_node_ring_out_wire_0_readdata;
   logic [7:0] cra_ring_node_ring_out_wire_0_byteena;
   logic cra_ring_node_ring_out_wire_0_datavalid;

   // INST cra_root of cra_ring_root
   cra_ring_root
   #(
      .ADDR_W(5),
      .AGENT_PORT_WAITREQUEST_ALLOWANCE(0),
      .ALLOW_HIGH_SPEED_FIFO_USAGE(0),
      .ASYNC_RESET(0),
      .DATA_W(64),
      .ID_W(0),
      .ROM_ENABLE(0),
      .ROM_EXT_W(0),
      .SYNCHRONIZE_RESET(1),
      .ZERO_LATENCY(1)
   )
   cra_root
   (
      // AVS avs
      .avs_enable(csr_ring_root_avs_enable),
      .avs_read(csr_ring_root_avs_read),
      .avs_write(csr_ring_root_avs_write),
      .avs_addr(csr_ring_root_avs_address),
      .avs_writedata(csr_ring_root_avs_writedata),
      .avs_byteena(csr_ring_root_avs_byteenable),
      .avs_waitrequest(csr_ring_root_avs_waitrequest),
      .avs_readdata(csr_ring_root_avs_readdata),
      .avs_readdatavalid(csr_ring_root_avs_readdatavalid),
      // AVS ri
      .ri_read(cra_ring_node_ring_out_wire_0_read),
      .ri_write(cra_ring_node_ring_out_wire_0_write),
      .ri_addr(cra_ring_node_ring_out_wire_0_addr),
      .ri_data(cra_ring_node_ring_out_wire_0_data),
      .ri_readdata(cra_ring_node_ring_out_wire_0_readdata),
      .ri_byteena(cra_ring_node_ring_out_wire_0_byteena),
      .ri_datavalid(cra_ring_node_ring_out_wire_0_datavalid),
      // AVS ro
      .ro_read(csr_ring_root_ring_out_wire_read),
      .ro_write(csr_ring_root_ring_out_wire_write),
      .ro_addr(csr_ring_root_ring_out_wire_addr),
      .ro_data(csr_ring_root_ring_out_wire_data),
      .ro_readdata(csr_ring_root_ring_out_wire_readdata),
      .ro_byteena(csr_ring_root_ring_out_wire_byteena),
      .ro_datavalid(csr_ring_root_ring_out_wire_datavalid),
      .clk(clock),
      .rst_n(resetn)
   );

   // INST csr_ring_node_avm_wire_0_cra_ring_inst_0 of cra_ring_node
   cra_ring_node
   #(
      .ASYNC_RESET(0),
      .CRA_ADDR_W(5),
      .DATA_W(64),
      .ID(0),
      .ID_W(0),
      .RING_ADDR_W(5),
      .SYNCHRONIZE_RESET(1),
      .ZERO_LATENCY(1)
   )
   csr_ring_node_avm_wire_0_cra_ring_inst_0
   (
      // AVM avm
      .avm_enable(cra_ring_avm_0_enable),
      .avm_read(cra_ring_avm_0_read),
      .avm_write(cra_ring_avm_0_write),
      .avm_addr(cra_ring_avm_0_address),
      .avm_writedata(cra_ring_avm_0_writedata),
      .avm_byteena(cra_ring_avm_0_byteenable),
      .avm_readdata(cra_ring_avm_0_readdata),
      .avm_readdatavalid(cra_ring_avm_0_readdatavalid),
      .avm_burstcount(cra_ring_avm_0_burstcount),
      // AVS ri
      .ri_read(csr_ring_root_ring_out_wire_read),
      .ri_write(csr_ring_root_ring_out_wire_write),
      .ri_addr(csr_ring_root_ring_out_wire_addr),
      .ri_data(csr_ring_root_ring_out_wire_data),
      .ri_readdata(csr_ring_root_ring_out_wire_readdata),
      .ri_byteena(csr_ring_root_ring_out_wire_byteena),
      .ri_datavalid(csr_ring_root_ring_out_wire_datavalid),
      // AVS ro
      .ro_read(cra_ring_node_ring_out_wire_0_read),
      .ro_write(cra_ring_node_ring_out_wire_0_write),
      .ro_addr(cra_ring_node_ring_out_wire_0_addr),
      .ro_data(cra_ring_node_ring_out_wire_0_data),
      .ro_readdata(cra_ring_node_ring_out_wire_0_readdata),
      .ro_byteena(cra_ring_node_ring_out_wire_0_byteena),
      .ro_datavalid(cra_ring_node_ring_out_wire_0_datavalid),
      .clk(clock),
      .rst_n(resetn)
   );

endmodule

